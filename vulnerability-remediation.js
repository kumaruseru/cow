#!/usr/bin/env node

/**
 * Security Vulnerability Remediation Plan
 * Based on Comprehensive Security Assessment Results
 */

const fs = require('fs');

class VulnerabilityRemediator {
  constructor() {
    this.fixes = [];
  }

  async createRemediationPlan() {
    console.log('🛠️ SECURITY VULNERABILITY REMEDIATION PLAN');
    console.log('═'.repeat(60));
    console.log('Creating automated fixes for identified vulnerabilities...\n');

    await this.fixSecurityHeaders();
    await this.fixInputValidation();
    await this.fixDatabaseSecurity();
    await this.fixClientSideSecurity();
    await this.fixErrorHandling();
    await this.generateSecureConfigTemplates();
    await this.createSecurityMiddleware();

    this.generateRemediationReport();
  }

  async fixSecurityHeaders() {
    console.log('🛡️ Fixing Security Headers Implementation...');
    console.log('─'.repeat(50));

    // Enhanced security middleware
    const securityMiddleware = `const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Comprehensive security headers
const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"],
      scriptSrc: ["'self'", "https://cdnjs.cloudflare.com"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      baseUri: ["'self'"],
      formAction: ["'self'"]
    }
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: "cross-origin" },
  dnsPrefetchControl: true,
  frameguard: { action: 'deny' },
  hidePoweredBy: true,
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  ieNoOpen: true,
  noSniff: true,
  originAgentCluster: true,
  permittedCrossDomainPolicies: false,
  referrerPolicy: { policy: "no-referrer" },
  xssFilter: true
});

// Enhanced rate limiting
const createRateLimit = (windowMs, max, skipSuccessful = true) => {
  return rateLimit({
    windowMs,
    max,
    skipSuccessful,
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      res.status(429).json({
        success: false,
        error: 'Too many requests, please try again later',
        code: 'RATE_LIMIT_EXCEEDED',
        retryAfter: Math.ceil(windowMs / 1000)
      });
    }
  });
};

const rateLimits = {
  // Authentication endpoints - very strict
  auth: createRateLimit(15 * 60 * 1000, 5, false), // 5 attempts per 15 minutes
  
  // Password reset - strict
  passwordReset: createRateLimit(60 * 60 * 1000, 3, false), // 3 attempts per hour
  
  // General API - moderate
  api: createRateLimit(15 * 60 * 1000, 100), // 100 requests per 15 minutes
  
  // File upload - restrictive
  upload: createRateLimit(60 * 60 * 1000, 10), // 10 uploads per hour
  
  // Search - moderate
  search: createRateLimit(60 * 1000, 30) // 30 searches per minute
};

module.exports = {
  securityHeaders,
  rateLimits
};`;

    try {
      fs.writeFileSync('middleware/enhanced-security.js', securityMiddleware);
      this.fixes.push({
        category: 'Security Headers',
        file: 'middleware/enhanced-security.js',
        description: 'Created comprehensive security headers and rate limiting middleware',
        status: 'CREATED'
      });
      console.log('✅ Created enhanced security middleware');
    } catch (error) {
      console.log('❌ Failed to create security middleware:', error.message);
    }
  }

  async fixInputValidation() {
    console.log('🔒 Fixing Input Validation and Sanitization...');
    console.log('─'.repeat(50));

    const validationMiddleware = `const { body, param, query, validationResult } = require('express-validator');
const DOMPurify = require('isomorphic-dompurify');
const mongoSanitize = require('express-mongo-sanitize');

// Input sanitization middleware
const sanitizeInput = (req, res, next) => {
  // Sanitize against NoSQL injection
  req.body = mongoSanitize.sanitize(req.body);
  req.query = mongoSanitize.sanitize(req.query);
  req.params = mongoSanitize.sanitize(req.params);

  // Sanitize HTML content
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = DOMPurify.sanitize(req.body[key]);
      }
    });
  }

  next();
};

// Enhanced validation rules
const validationRules = {
  // User registration validation
  register: [
    body('firstName')
      .trim()
      .isLength({ min: 1, max: 50 })
      .matches(/^[a-zA-ZÀ-ÿ\\s]+$/)
      .withMessage('First name must contain only letters and spaces'),
    
    body('lastName')
      .trim()
      .isLength({ min: 1, max: 50 })
      .matches(/^[a-zA-ZÀ-ÿ\\s]+$/)
      .withMessage('Last name must contain only letters and spaces'),
    
    body('email')
      .isEmail()
      .normalizeEmail()
      .isLength({ max: 100 })
      .withMessage('Valid email address required'),
    
    body('password')
      .isLength({ min: 8, max: 128 })
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)
      .withMessage('Password must contain at least 8 characters with uppercase, lowercase, number and special character'),
    
    body('birthDate')
      .optional()
      .isISO8601()
      .custom(date => {
        const birth = new Date(date);
        const today = new Date();
        const age = today.getFullYear() - birth.getFullYear();
        if (age < 13 || age > 120) {
          throw new Error('Age must be between 13 and 120 years');
        }
        return true;
      }),
    
    body('gender')
      .optional()
      .isIn(['male', 'female', 'other'])
      .withMessage('Gender must be male, female, or other')
  ],

  // User login validation
  login: [
    body('email')
      .isEmail()
      .normalizeEmail()
      .withMessage('Valid email address required'),
    
    body('password')
      .isLength({ min: 1, max: 128 })
      .withMessage('Password is required')
  ],

  // Post creation validation
  createPost: [
    body('content')
      .trim()
      .isLength({ min: 1, max: 5000 })
      .withMessage('Post content must be between 1 and 5000 characters'),
    
    body('privacy')
      .optional()
      .isIn(['public', 'friends', 'private'])
      .withMessage('Privacy must be public, friends, or private')
  ],

  // Message validation
  sendMessage: [
    body('recipientId')
      .isMongoId()
      .withMessage('Valid recipient ID required'),
    
    body('content')
      .trim()
      .isLength({ min: 1, max: 1000 })
      .withMessage('Message content must be between 1 and 1000 characters')
  ],

  // File upload validation
  fileUpload: [
    body('description')
      .optional()
      .trim()
      .isLength({ max: 500 })
      .withMessage('Description must be less than 500 characters')
  ],

  // Search validation
  search: [
    query('q')
      .trim()
      .isLength({ min: 1, max: 100 })
      .matches(/^[a-zA-Z0-9À-ÿ\\s\\-_.@]+$/)
      .withMessage('Search query contains invalid characters'),
    
    query('type')
      .optional()
      .isIn(['users', 'posts', 'all'])
      .withMessage('Search type must be users, posts, or all'),
    
    query('limit')
      .optional()
      .isInt({ min: 1, max: 50 })
      .withMessage('Limit must be between 1 and 50')
  ]
};

// Validation error handler
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    const formattedErrors = errors.array().map(error => ({
      field: error.path,
      message: error.msg,
      value: error.value
    }));

    return res.status(400).json({
      success: false,
      error: 'Validation failed',
      code: 'VALIDATION_ERROR',
      details: formattedErrors
    });
  }
  
  next();
};

module.exports = {
  sanitizeInput,
  validationRules,
  handleValidationErrors
};`;

    try {
      fs.writeFileSync('middleware/enhanced-validation.js', validationMiddleware);
      this.fixes.push({
        category: 'Input Validation',
        file: 'middleware/enhanced-validation.js',
        description: 'Created comprehensive input validation and sanitization middleware',
        status: 'CREATED'
      });
      console.log('✅ Created enhanced validation middleware');
    } catch (error) {
      console.log('❌ Failed to create validation middleware:', error.message);
    }
  }

  async fixDatabaseSecurity() {
    console.log('🗄️ Fixing Database Security Configuration...');
    console.log('─'.repeat(50));

    const secureDbConfig = `const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Enhanced database connection with security
const connectDB = async () => {
  try {
    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/cow_social';
    
    // Production security options
    const connectionOptions = {
      // Connection management
      maxPoolSize: parseInt(process.env.DB_MAX_POOL_SIZE) || 10,
      minPoolSize: parseInt(process.env.DB_MIN_POOL_SIZE) || 5,
      maxIdleTimeMS: parseInt(process.env.DB_MAX_IDLE_TIME) || 30000,
      serverSelectionTimeoutMS: parseInt(process.env.DB_SERVER_TIMEOUT) || 5000,
      socketTimeoutMS: parseInt(process.env.DB_SOCKET_TIMEOUT) || 45000,
      family: 4,
      
      // Security options
      authSource: process.env.DB_AUTH_SOURCE || 'admin',
      ssl: process.env.NODE_ENV === 'production',
      sslValidate: process.env.NODE_ENV === 'production',
      
      // Read/Write concerns for data integrity
      readConcern: { level: 'majority' },
      writeConcern: { w: 'majority', j: true },
      
      // Additional security
      retryWrites: true,
      retryReads: true
    };

    // Add SSL certificate paths for production
    if (process.env.NODE_ENV === 'production') {
      if (process.env.DB_SSL_CERT) {
        connectionOptions.sslCert = process.env.DB_SSL_CERT;
      }
      if (process.env.DB_SSL_KEY) {
        connectionOptions.sslKey = process.env.DB_SSL_KEY;
      }
      if (process.env.DB_SSL_CA) {
        connectionOptions.sslCA = process.env.DB_SSL_CA;
      }
    }

    await mongoose.connect(mongoURI, connectionOptions);

    logger.info(\`✅ MongoDB Connected: \${mongoose.connection.host}\`);
    logger.info(\`🔒 SSL Enabled: \${connectionOptions.ssl || false}\`);
    
    // Security event listeners
    mongoose.connection.on('error', (err) => {
      logger.error('❌ MongoDB connection error:', err);
    });

    mongoose.connection.on('disconnected', () => {
      logger.warn('⚠️ MongoDB disconnected');
    });

    mongoose.connection.on('reconnected', () => {
      logger.info('🔄 MongoDB reconnected');
    });

    // Performance monitoring
    mongoose.connection.on('slow', (details) => {
      logger.warn('🐌 Slow MongoDB operation:', details);
    });

    // Graceful shutdown with cleanup
    const gracefulShutdown = async (signal) => {
      logger.info(\`📦 Received \${signal}, closing MongoDB connection...\`);
      
      try {
        await mongoose.connection.close(false);
        logger.info('📦 MongoDB connection closed successfully');
        process.exit(0);
      } catch (err) {
        logger.error('❌ Error during MongoDB shutdown:', err);
        process.exit(1);
      }
    };

    process.on('SIGINT', () => gracefulShutdown('SIGINT'));
    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGUSR2', () => gracefulShutdown('SIGUSR2')); // For nodemon

  } catch (error) {
    logger.error('❌ MongoDB connection failed:', error.message);
    
    // Security: Don't expose connection details in error
    if (process.env.NODE_ENV === 'production') {
      process.exit(1);
    } else {
      console.error('Development error details:', error);
      process.exit(1);
    }
  }
};

// Database health check
const checkDatabaseHealth = async () => {
  try {
    const result = await mongoose.connection.db.admin().ping();
    return { healthy: true, latency: Date.now() };
  } catch (error) {
    logger.error('Database health check failed:', error);
    return { healthy: false, error: error.message };
  }
};

// Query performance monitoring
const monitorQuery = (query, threshold = 100) => {
  const start = Date.now();
  
  return {
    end: () => {
      const duration = Date.now() - start;
      if (duration > threshold) {
        logger.warn('Slow query detected:', {
          query: query.toString(),
          duration: \`\${duration}ms\`,
          threshold: \`\${threshold}ms\`
        });
      }
      return duration;
    }
  };
};

module.exports = {
  connectDB,
  checkDatabaseHealth,
  monitorQuery
};`;

    try {
      fs.writeFileSync('config/secure-database.js', secureDbConfig);
      this.fixes.push({
        category: 'Database Security',
        file: 'config/secure-database.js',
        description: 'Created secure database configuration with SSL and monitoring',
        status: 'CREATED'
      });
      console.log('✅ Created secure database configuration');
    } catch (error) {
      console.log('❌ Failed to create database config:', error.message);
    }
  }

  async fixClientSideSecurity() {
    console.log('🌐 Fixing Client-Side Security Issues...');
    console.log('─'.repeat(50));

    // Create secure JavaScript file to replace inline scripts
    const secureJs = `// Secure JavaScript for Cow Social Network
'use strict';

// Security configuration
const SecurityConfig = {
  // API endpoints
  API_BASE: '/api',
  
  // Security headers
  headers: {
    'Content-Type': 'application/json',
    'X-Requested-With': 'XMLHttpRequest'
  },
  
  // Input validation patterns
  patterns: {
    email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,
    password: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/,
    name: /^[a-zA-ZÀ-ÿ\\s]{1,50}$/
  }
};

// Secure HTTP client
class SecureHTTP {
  static async request(method, url, data = null) {
    const token = localStorage.getItem('accessToken');
    
    const config = {
      method: method.toUpperCase(),
      headers: {
        ...SecurityConfig.headers,
        ...(token && { 'Authorization': \`Bearer \${token}\` })
      }
    };

    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      config.body = JSON.stringify(data);
    }

    try {
      const response = await fetch(url, config);
      
      // Check for authentication errors
      if (response.status === 401) {
        // Token expired or invalid
        this.handleAuthError();
        throw new Error('Authentication required');
      }

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Request failed');
      }

      return await response.json();
    } catch (error) {
      console.error('HTTP request failed:', error);
      throw error;
    }
  }

  static handleAuthError() {
    // Clear invalid tokens
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    
    // Redirect to login if not already there
    if (!window.location.pathname.includes('/login')) {
      window.location.href = '/login.html';
    }
  }
}

// Input sanitization
class InputSanitizer {
  static sanitizeHTML(input) {
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  }

  static validateEmail(email) {
    return SecurityConfig.patterns.email.test(email);
  }

  static validatePassword(password) {
    return SecurityConfig.patterns.password.test(password);
  }

  static validateName(name) {
    return SecurityConfig.patterns.name.test(name);
  }

  static sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    return input
      .trim()
      .replace(/[<>"\\']/g, '') // Remove dangerous characters
      .substring(0, 1000); // Limit length
  }
}

// Form validation
class FormValidator {
  static validateRegistrationForm(formData) {
    const errors = [];

    if (!InputSanitizer.validateName(formData.firstName)) {
      errors.push('First name must contain only letters and spaces (1-50 characters)');
    }

    if (!InputSanitizer.validateName(formData.lastName)) {
      errors.push('Last name must contain only letters and spaces (1-50 characters)');
    }

    if (!InputSanitizer.validateEmail(formData.email)) {
      errors.push('Please enter a valid email address');
    }

    if (!InputSanitizer.validatePassword(formData.password)) {
      errors.push('Password must contain at least 8 characters with uppercase, lowercase, number and special character');
    }

    if (formData.password !== formData.confirmPassword) {
      errors.push('Passwords do not match');
    }

    return errors;
  }

  static validateLoginForm(formData) {
    const errors = [];

    if (!InputSanitizer.validateEmail(formData.email)) {
      errors.push('Please enter a valid email address');
    }

    if (!formData.password || formData.password.length < 1) {
      errors.push('Password is required');
    }

    return errors;
  }
}

// Secure event handlers
class SecureEventHandlers {
  static async handleLogin(event) {
    event.preventDefault();
    
    const form = event.target;
    const formData = new FormData(form);
    
    const loginData = {
      email: InputSanitizer.sanitizeInput(formData.get('email')),
      password: formData.get('password') // Don't sanitize password
    };

    // Validate form
    const errors = FormValidator.validateLoginForm(loginData);
    if (errors.length > 0) {
      this.showErrors(errors);
      return;
    }

    try {
      const response = await SecureHTTP.request('POST', '/api/auth/login', loginData);
      
      if (response.success) {
        // Store tokens securely
        localStorage.setItem('accessToken', response.accessToken);
        if (response.refreshToken) {
          localStorage.setItem('refreshToken', response.refreshToken);
        }
        
        // Redirect to dashboard
        window.location.href = '/home.html';
      } else {
        this.showErrors([response.error || 'Login failed']);
      }
    } catch (error) {
      this.showErrors([error.message || 'Login failed']);
    }
  }

  static async handleRegistration(event) {
    event.preventDefault();
    
    const form = event.target;
    const formData = new FormData(form);
    
    const registrationData = {
      firstName: InputSanitizer.sanitizeInput(formData.get('firstName')),
      lastName: InputSanitizer.sanitizeInput(formData.get('lastName')),
      email: InputSanitizer.sanitizeInput(formData.get('email')),
      password: formData.get('password'), // Don't sanitize password
      confirmPassword: formData.get('confirmPassword'),
      birthDate: formData.get('birthDate'),
      gender: formData.get('gender')
    };

    // Validate form
    const errors = FormValidator.validateRegistrationForm(registrationData);
    if (errors.length > 0) {
      this.showErrors(errors);
      return;
    }

    // Remove confirmPassword before sending
    delete registrationData.confirmPassword;

    try {
      const response = await SecureHTTP.request('POST', '/api/auth/register', registrationData);
      
      if (response.success) {
        // Store tokens securely
        localStorage.setItem('accessToken', response.accessToken);
        if (response.refreshToken) {
          localStorage.setItem('refreshToken', response.refreshToken);
        }
        
        // Redirect to dashboard
        window.location.href = '/home.html';
      } else {
        this.showErrors([response.error || 'Registration failed']);
      }
    } catch (error) {
      this.showErrors([error.message || 'Registration failed']);
    }
  }

  static showErrors(errors) {
    const errorContainer = document.getElementById('error-messages');
    if (errorContainer) {
      errorContainer.innerHTML = errors
        .map(error => \`<div class="alert alert-danger">\${InputSanitizer.sanitizeHTML(error)}</div>\`)
        .join('');
      errorContainer.style.display = 'block';
    }
  }

  static hideErrors() {
    const errorContainer = document.getElementById('error-messages');
    if (errorContainer) {
      errorContainer.style.display = 'none';
    }
  }
}

// Initialize secure functionality when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  // Bind secure event handlers
  const loginForm = document.getElementById('login-form');
  if (loginForm) {
    loginForm.addEventListener('submit', SecureEventHandlers.handleLogin.bind(SecureEventHandlers));
  }

  const registerForm = document.getElementById('register-form');
  if (registerForm) {
    registerForm.addEventListener('submit', SecureEventHandlers.handleRegistration.bind(SecureEventHandlers));
  }

  // Hide error messages when user starts typing
  const inputs = document.querySelectorAll('input');
  inputs.forEach(input => {
    input.addEventListener('input', SecureEventHandlers.hideErrors);
  });
});

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    SecurityConfig,
    SecureHTTP,
    InputSanitizer,
    FormValidator,
    SecureEventHandlers
  };
}`;

    try {
      fs.writeFileSync('js/secure-app.js', secureJs);
      this.fixes.push({
        category: 'Client-Side Security',
        file: 'js/secure-app.js',
        description: 'Created secure JavaScript file to replace inline scripts',
        status: 'CREATED'
      });
      console.log('✅ Created secure client-side JavaScript');
    } catch (error) {
      console.log('❌ Failed to create secure JavaScript:', error.message);
    }
  }

  async fixErrorHandling() {
    console.log('❌ Fixing Error Handling Security...');
    console.log('─'.repeat(50));

    const secureErrorHandler = `const logger = require('../utils/logger');

// Enhanced error handling middleware
const secureErrorHandler = (err, req, res, next) => {
  // Log full error details for internal use
  logger.error('Application error:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    user: req.user?.id || 'anonymous',
    timestamp: new Date().toISOString()
  });

  // Determine error status code
  let statusCode = err.statusCode || err.status || 500;
  
  // Security-conscious error response
  const errorResponse = {
    success: false,
    timestamp: new Date().toISOString(),
    path: req.url,
    method: req.method
  };

  // Handle specific error types
  switch (err.name) {
    case 'ValidationError':
      statusCode = 400;
      errorResponse.error = 'Validation failed';
      errorResponse.code = 'VALIDATION_ERROR';
      if (process.env.NODE_ENV === 'development') {
        errorResponse.details = err.errors;
      }
      break;

    case 'CastError':
      statusCode = 400;
      errorResponse.error = 'Invalid data format';
      errorResponse.code = 'INVALID_FORMAT';
      break;

    case 'MongoServerError':
      if (err.code === 11000) {
        statusCode = 409;
        errorResponse.error = 'Resource already exists';
        errorResponse.code = 'DUPLICATE_RESOURCE';
      } else {
        statusCode = 500;
        errorResponse.error = 'Database error';
        errorResponse.code = 'DATABASE_ERROR';
      }
      break;

    case 'JsonWebTokenError':
      statusCode = 401;
      errorResponse.error = 'Invalid authentication token';
      errorResponse.code = 'INVALID_TOKEN';
      break;

    case 'TokenExpiredError':
      statusCode = 401;
      errorResponse.error = 'Authentication token expired';
      errorResponse.code = 'TOKEN_EXPIRED';
      break;

    case 'MulterError':
      statusCode = 400;
      if (err.code === 'LIMIT_FILE_SIZE') {
        errorResponse.error = 'File too large';
        errorResponse.code = 'FILE_TOO_LARGE';
      } else if (err.code === 'LIMIT_FILE_COUNT') {
        errorResponse.error = 'Too many files';
        errorResponse.code = 'TOO_MANY_FILES';
      } else {
        errorResponse.error = 'File upload error';
        errorResponse.code = 'UPLOAD_ERROR';
      }
      break;

    default:
      // Generic server error
      if (statusCode >= 500) {
        errorResponse.error = 'Internal server error';
        errorResponse.code = 'INTERNAL_ERROR';
      } else {
        errorResponse.error = err.message || 'Bad request';
        errorResponse.code = err.code || 'BAD_REQUEST';
      }
  }

  // Only include sensitive details in development
  if (process.env.NODE_ENV === 'development') {
    errorResponse.stack = err.stack;
    errorResponse.details = {
      name: err.name,
      message: err.message,
      ...(err.errors && { validationErrors: err.errors })
    };
  }

  // Security headers for error responses
  res.set({
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block'
  });

  res.status(statusCode).json(errorResponse);
};

// 404 handler
const notFoundHandler = (req, res) => {
  logger.warn('404 Not Found:', {
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  res.status(404).json({
    success: false,
    error: 'Resource not found',
    code: 'NOT_FOUND',
    timestamp: new Date().toISOString(),
    path: req.url
  });
};

// Async error wrapper
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Request timeout handler
const timeoutHandler = (timeout = 30000) => (req, res, next) => {
  const timer = setTimeout(() => {
    const error = new Error('Request timeout');
    error.statusCode = 408;
    error.code = 'REQUEST_TIMEOUT';
    next(error);
  }, timeout);

  res.on('finish', () => {
    clearTimeout(timer);
  });

  res.on('close', () => {
    clearTimeout(timer);
  });

  next();
};

module.exports = {
  secureErrorHandler,
  notFoundHandler,
  asyncHandler,
  timeoutHandler
};`;

    try {
      fs.writeFileSync('middleware/secure-error-handler.js', secureErrorHandler);
      this.fixes.push({
        category: 'Error Handling',
        file: 'middleware/secure-error-handler.js',
        description: 'Created secure error handling middleware without information disclosure',
        status: 'CREATED'
      });
      console.log('✅ Created secure error handling middleware');
    } catch (error) {
      console.log('❌ Failed to create error handler:', error.message);
    }
  }

  async generateSecureConfigTemplates() {
    console.log('⚙️ Generating Secure Configuration Templates...');
    console.log('─'.repeat(50));

    // Secure .env template
    const envTemplate = `# Cow Social Network - Secure Environment Configuration
# Copy this file to .env and fill in your actual values

# ============================================================================
# SERVER CONFIGURATION
# ============================================================================
NODE_ENV=production
PORT=3000
SERVER_URL=https://your-domain.com

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/cow_social?retryWrites=true&w=majority&ssl=true
DB_MAX_POOL_SIZE=10
DB_MIN_POOL_SIZE=5
DB_MAX_IDLE_TIME=30000
DB_SERVER_TIMEOUT=5000
DB_SOCKET_TIMEOUT=45000
DB_AUTH_SOURCE=admin

# SSL Configuration (for production)
# DB_SSL_CERT=/path/to/cert.pem
# DB_SSL_KEY=/path/to/key.pem
# DB_SSL_CA=/path/to/ca.pem

# ============================================================================
# AUTHENTICATION & SECURITY
# ============================================================================
# Generate strong secrets: openssl rand -base64 32
JWT_SECRET=your-super-strong-jwt-secret-minimum-32-characters
JWT_EXPIRE=15m
JWT_REFRESH_SECRET=your-super-strong-refresh-secret-minimum-32-characters
JWT_REFRESH_EXPIRE=7d

SESSION_SECRET=your-super-strong-session-secret-minimum-32-characters
ENCRYPTION_KEY=your-super-strong-encryption-key-32-characters

# ============================================================================
# PASSWORD & SECURITY SETTINGS
# ============================================================================
BCRYPT_SALT_ROUNDS=12
ADMIN_PASSWORD=your-super-strong-admin-password

# ============================================================================
# RATE LIMITING & SECURITY
# ============================================================================
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
AUTH_RATE_LIMIT_MAX=5
AUTH_RATE_LIMIT_WINDOW=900000

# ============================================================================
# FILE UPLOAD CONFIGURATION
# ============================================================================
MAX_FILE_SIZE=5242880
MAX_JSON_SIZE=10mb
MAX_FORM_SIZE=10mb
UPLOAD_PATH=./uploads

# ============================================================================
# EMAIL CONFIGURATION
# ============================================================================
SMTP_HOST=smtp.your-email-provider.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=your-email@domain.com
SMTP_PASS=your-email-password
FROM_EMAIL=noreply@your-domain.com
FROM_NAME=Cow Social Network

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================
LOG_LEVEL=info
LOG_FILE_MAX_SIZE=20m
LOG_FILE_MAX_FILES=14d

# ============================================================================
# REDIS CONFIGURATION (for sessions and caching)
# ============================================================================
REDIS_URL=redis://localhost:6379
REDIS_PASSWORD=your-redis-password

# ============================================================================
# CLOUDINARY (for file storage)
# ============================================================================
CLOUDINARY_CLOUD_NAME=your-cloud-name
CLOUDINARY_API_KEY=your-api-key
CLOUDINARY_API_SECRET=your-api-secret

# ============================================================================
# SECURITY HEADERS
# ============================================================================
CORS_ORIGIN=https://your-domain.com
CORS_CREDENTIALS=true

# ============================================================================
# MONITORING & ANALYTICS
# ============================================================================
SENTRY_DSN=your-sentry-dsn
GOOGLE_ANALYTICS_ID=your-ga-id

# ============================================================================
# DEVELOPMENT ONLY (remove in production)
# ============================================================================
# DEBUG=cow:*
# VERBOSE_LOGGING=true`;

    // Docker security configuration
    const dockerSecurity = `# Docker Security Configuration for Cow Social Network

# Use official Node.js runtime as base image
FROM node:18-alpine

# Create app directory with non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy application code
COPY --chown=nextjs:nodejs . .

# Remove unnecessary files
RUN rm -rf .git .env.example README.md docs/ tests/

# Security: Run as non-root user
USER nextjs

# Expose port
EXPOSE 3000

# Security headers and limits
ENV NODE_OPTIONS="--max-old-space-size=1024"
ENV NODE_ENV=production

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node healthcheck.js

# Start application
CMD ["node", "server.js"]`;

    // Nginx security configuration
    const nginxConfig = `# Nginx Security Configuration for Cow Social Network

server {
    listen 80;
    server_name your-domain.com www.your-domain.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # SSL Configuration
    ssl_certificate /path/to/your/cert.pem;
    ssl_certificate_key /path/to/your/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Security Headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self'; font-src 'self'; object-src 'none'; media-src 'self'; form-action 'self';" always;

    # Rate Limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=auth:10m rate=1r/s;

    # File Upload Limits
    client_max_body_size 10M;
    client_body_timeout 12;
    client_header_timeout 12;
    keepalive_timeout 15;
    send_timeout 10;

    # Proxy to Node.js application
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeout settings
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }

    # API Rate Limiting
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://localhost:3000;
        # ... other proxy settings
    }

    # Authentication endpoints - stricter rate limiting
    location /api/auth/ {
        limit_req zone=auth burst=5 nodelay;
        proxy_pass http://localhost:3000;
        # ... other proxy settings
    }

    # Static files
    location /uploads/ {
        alias /app/uploads/;
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header X-Content-Type-Options nosniff;
        
        # Prevent execution of uploaded files
        location ~* \\.(php|jsp|asp|sh|pl|py|exe)$ {
            deny all;
        }
    }

    # Security: Hide server information
    server_tokens off;
    
    # Log security events
    access_log /var/log/nginx/cow-access.log;
    error_log /var/log/nginx/cow-error.log warn;
}`;

    try {
      fs.writeFileSync('.env.example', envTemplate);
      fs.writeFileSync('Dockerfile.secure', dockerSecurity);
      fs.writeFileSync('nginx.conf.example', nginxConfig);
      
      this.fixes.push({
        category: 'Configuration',
        file: '.env.example',
        description: 'Created secure environment configuration template',
        status: 'CREATED'
      });
      
      this.fixes.push({
        category: 'Configuration',
        file: 'Dockerfile.secure',
        description: 'Created secure Docker configuration',
        status: 'CREATED'
      });
      
      this.fixes.push({
        category: 'Configuration',
        file: 'nginx.conf.example',
        description: 'Created secure Nginx configuration template',
        status: 'CREATED'
      });
      
      console.log('✅ Created secure configuration templates');
    } catch (error) {
      console.log('❌ Failed to create config templates:', error.message);
    }
  }

  async createSecurityMiddleware() {
    console.log('🛡️ Creating Integrated Security Middleware...');
    console.log('─'.repeat(50));

    const integratedSecurity = `// Integrated Security Middleware for Cow Social Network
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const hpp = require('hpp');
const cors = require('cors');
const compression = require('compression');

// Import our custom security modules
const { securityHeaders, rateLimits } = require('./enhanced-security');
const { sanitizeInput, validationRules, handleValidationErrors } = require('./enhanced-validation');
const { secureErrorHandler, notFoundHandler, asyncHandler, timeoutHandler } = require('./secure-error-handler');

// Comprehensive security middleware stack
const applySecurityMiddleware = (app) => {
  // 1. Trust proxy for proper IP detection
  app.set('trust proxy', 1);

  // 2. Request timeout protection
  app.use(timeoutHandler(30000));

  // 3. Compression (before other middleware)
  app.use(compression());

  // 4. Security headers (Helmet.js)
  app.use(securityHeaders);

  // 5. CORS configuration
  const corsOptions = {
    origin: function (origin, callback) {
      const allowedOrigins = process.env.CORS_ORIGIN 
        ? process.env.CORS_ORIGIN.split(',')
        : ['http://localhost:3000', 'http://localhost:3001'];
      
      // Allow requests with no origin (mobile apps, etc.)
      if (!origin) return callback(null, true);
      
      if (allowedOrigins.indexOf(origin) !== -1) {
        callback(null, true);
      } else {
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    exposedHeaders: ['X-RateLimit-Limit', 'X-RateLimit-Remaining'],
    maxAge: 86400 // 24 hours
  };
  app.use(cors(corsOptions));

  // 6. Body parsing with security limits
  app.use(express.json({ 
    limit: process.env.MAX_JSON_SIZE || '10mb',
    verify: (req, res, buf) => {
      try {
        JSON.parse(buf);
      } catch (e) {
        const error = new Error('Invalid JSON payload');
        error.statusCode = 400;
        error.code = 'INVALID_JSON';
        throw error;
      }
    }
  }));
  
  app.use(express.urlencoded({ 
    extended: true, 
    limit: process.env.MAX_FORM_SIZE || '10mb' 
  }));

  // 7. Input sanitization
  app.use(mongoSanitize());
  app.use(hpp()); // Prevent HTTP Parameter Pollution
  app.use(sanitizeInput);

  // 8. Apply rate limiting
  app.use('/api/auth/', rateLimits.auth);
  app.use('/api/auth/reset-password', rateLimits.passwordReset);
  app.use('/api/upload/', rateLimits.upload);
  app.use('/api/search/', rateLimits.search);
  app.use('/api/', rateLimits.api);

  console.log('🛡️ Security middleware applied successfully');
};

// Apply validation to routes
const applyValidationRules = (app) => {
  // Authentication routes
  app.use('/api/auth/register', validationRules.register, handleValidationErrors);
  app.use('/api/auth/login', validationRules.login, handleValidationErrors);
  
  // Post routes
  app.use('/api/posts', validationRules.createPost, handleValidationErrors);
  
  // Message routes
  app.use('/api/messages', validationRules.sendMessage, handleValidationErrors);
  
  // File upload routes
  app.use('/api/upload', validationRules.fileUpload, handleValidationErrors);
  
  // Search routes
  app.use('/api/search', validationRules.search, handleValidationErrors);

  console.log('✅ Validation rules applied to routes');
};

// Apply error handling
const applyErrorHandling = (app) => {
  // 404 handler for API routes
  app.use('/api/*', notFoundHandler);
  
  // Global error handler
  app.use(secureErrorHandler);

  console.log('❌ Error handling middleware applied');
};

module.exports = {
  applySecurityMiddleware,
  applyValidationRules,
  applyErrorHandling,
  asyncHandler,
  securityHeaders,
  rateLimits
};`;

    try {
      fs.writeFileSync('middleware/integrated-security.js', integratedSecurity);
      this.fixes.push({
        category: 'Security Middleware',
        file: 'middleware/integrated-security.js',
        description: 'Created integrated security middleware for easy application',
        status: 'CREATED'
      });
      console.log('✅ Created integrated security middleware');
    } catch (error) {
      console.log('❌ Failed to create integrated security:', error.message);
    }
  }

  generateRemediationReport() {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalFixes: this.fixes.length,
        categoriesFixed: [...new Set(this.fixes.map(f => f.category))],
        filesCreated: this.fixes.length
      },
      fixes: this.fixes,
      nextSteps: [
        'Install required npm packages: npm install helmet express-rate-limit express-mongo-sanitize hpp isomorphic-dompurify',
        'Replace current middleware imports with new secure middleware',
        'Update server.js to use integrated security middleware',
        'Update .env file with secure configuration values',
        'Update HTML files to use external JavaScript instead of inline scripts',
        'Test all functionality after implementing security fixes',
        'Run security assessment again to verify improvements',
        'Configure SSL certificates for production deployment',
        'Set up monitoring and alerting for security events',
        'Conduct penetration testing to validate security improvements'
      ],
      implementation: {
        'High Priority (Fix Immediately)': [
          'Implement security headers middleware',
          'Add input validation and sanitization',
          'Fix client-side inline JavaScript',
          'Configure secure error handling'
        ],
        'Medium Priority (Fix This Week)': [
          'Enable database SSL/TLS',
          'Update configuration management',
          'Implement comprehensive rate limiting'
        ],
        'Low Priority (Fix This Month)': [
          'Update dependencies to latest versions',
          'Implement additional monitoring',
          'Optimize security headers configuration'
        ]
      }
    };

    fs.writeFileSync('security-remediation-report.json', JSON.stringify(report, null, 2));

    console.log('\n📋 VULNERABILITY REMEDIATION COMPLETE');
    console.log('═'.repeat(60));
    console.log(`Total Security Fixes Created: ${this.fixes.length}`);
    console.log(`Categories Addressed: ${report.summary.categoriesFixed.join(', ')}`);
    console.log('\n📁 Files Created:');
    this.fixes.forEach(fix => {
      console.log(`   ✅ ${fix.file} - ${fix.description}`);
    });
    console.log('\n💾 Implementation guide saved to: security-remediation-report.json');
    console.log('\n🔧 Next Steps:');
    report.nextSteps.slice(0, 5).forEach((step, index) => {
      console.log(`   ${index + 1}. ${step}`);
    });

    return report;
  }
}

async function runVulnerabilityRemediation() {
  const remediator = new VulnerabilityRemediator();
  return await remediator.createRemediationPlan();
}

module.exports = VulnerabilityRemediator;

if (require.main === module) {
  runVulnerabilityRemediation().catch(console.error);
}
